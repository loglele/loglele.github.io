<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EJB与JNDI</title>
    <url>/2016/04/04/EJB%E4%B8%8EJNDI/</url>
    <content><![CDATA[<blockquote class="blockquote-center">应用驱动学习</blockquote>
（摊手）

<p>第一次接触使用EJB构建项目部署。</p>
<p><code>EJB</code>(Enterprise JavaBean)是sun的JavaEE服务器端组件模型和“<code>最佳实践</code>（讲真，即使EJB3.0已经借鉴了Spring等优点，在我看来还是臃肿繁琐），设计目标与核心应用是部署分布式应用程序。</p>
<blockquote>
<p>凭借java跨平台的优势，用EJB技术部署的分布式系统可以不限于特定的平台。EJB是J2EE的一部分，定义了一个用于开发基于组件的企业多重应用程序的标准。其特点包括网络服务支持和核心开发工具(SDK)。 在J2EE里，Enterprise Java Beans(EJB)称为Java企业Bean，是Java的核心代码，分别是会话Bean（Session Bean），实体Bean（Entity Bean）和消息驱动Bean（MessageDriven Bean）。</p>
</blockquote>
<span id="more"></span>

<p>作为Java WEB项目构建，可以简单这么理解其工作流程：</p>
<p><strong>JSP → Servlet → Session Bean或MessageDriven Bean → Entity Bean → DB持久化</strong></p>
<p>…</p>
<p>（Spring不知道比它高到哪里去了）</p>
<p><code>JNDI</code>(The Java Naming and Directory Interface，Java 命名和目录接口) 是一组在Java 应用中访问命名和目录服务的API。为开发人员提供了查找和访问各种命名和目录服务的通用、统一的方式。借助于JNDI 提供的接口，能够通过名字定位用户、机器、网络、对象服务等。</p>
<p>与EJB通信必须借助JNDI的命名服务查找使用相关的Bean，其中：</p>
<p>local是本地接口，remote是远程接口。web层调用app层使用remote接口。session bena和entity bean之间<br>调用使用的是local接口。</p>
<p>因为JNDI是一组接口，所以我们只需根据接口规范编程就可以。要通过JNDI 进行资源访问，我们必须设置初始化上下文的参数，主要是设置JNDI 驱动的类名(java.naming.factory.initial) 和提供命名服务的URL (java.naming.provider.url)。</p>
<p>因为Jndi 的实现产品有很多。所以java.naming.factory.initial 的值因提供JNDI 服务器的不同而不同，java.naming.provider.url 的值包括提供命名服务的主机地址和端口号。</p>
<p>访问Jboss 服务器的例子代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.setProperty(<span class="string">&quot;java.naming.factory.initial&quot;</span>, <span class="string">&quot;org.jnp.interfaces.NamingContextFactory&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;java.naming.provider.url&quot;</span>, <span class="string">&quot;localhost:1099&quot;</span>);</span><br><span class="line">InitialContext ctx = <span class="keyword">new</span> InitialContext(props);</span><br><span class="line">HelloWorld helloworld = (HelloWorld) ctx.lookup(<span class="string">&quot;HelloWorldBean/remote&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不用说你也明白，remote接口对性能的影响是很大的。所以在设计的时候我们应尽量使用local接口，也就是facade模式。具体来说是，web层调用app层的session bean,session bean在调用各个实体entity bean。</p>
<p>local接口可以在与ejb同一个jvm环境中调用，但是不能对它进行远程调用的，在jndi查找的时候不能查找local home，而要查找remote home，也就是说需要实际进行RMI调用，而且必须提供Provider URL(例如t3://myserver:7001)，而且他们返回给客户的对象也不一样，local home创建的是javax.ejb.EJBLocalObject类型，它没有继承Remote interface；而Remote home创建的是javax.ejb.EJBObject类型的，它扩展了Remote。</p>
<p>实际上javax.ejb.EJBLoclObject型接口没有抛出RemoteException，因为对local类型接口的调用不是RMI，所以对Local接口的调用效率要高于对remote对象的调用，针对这点对EJB的设计提出以下建议：</p>
<ul>
<li><p>  如果你的ejb客户只可能存在于与ejb相同app server，或者说同一个JVM环境中时，你可以只生成local类型接口（包括EJBHome 与EJBObject），如果你需要在与EJB容器不同的JVM环境中调用你的EJB的话，你必须生成Remote类型的接口（包括EJBHome 与EJBObject）。</p>
</li>
<li><p>  在一般情况下建议两种类型的接口（包括EJBHome 与EJBObject）都生成，尤其是Session Bean，Entity Bean，可以只生成local类型的接口，如果想远程调用你的Entity Bean一般用Session Bean做代理。</p>
</li>
<li><p>  如果你不是远程调用EJB的话，使用EJB时建议调用local接口，这样效率高，因为远程调用就意味着建立网络连接，效率必然不如local调用。</p>
</li>
<li><p>  在Java EE 7中设计EJB时，默认情况下只给你生成local类型接口，所以你需要在设计EJB时把interfaces设成：local/remote，这样的话你的EJB至少会有5个java文件</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>EJB</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot多数据源切换与事务控制</title>
    <url>/2016/09/04/Spring%20Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>后台数据库读写分离，不光是要配置多个数据源，还得能灵活动态的切换数据源，很好，目前都没问题，然而如果你的应用是使用SpringBoot：</p>
<blockquote>
<p>SpringBoot使我们更容易去创建基于Spring的独立和产品级的可以“即时运行”的应用和服务。支持约定大于配置，目的是尽可能快地构建和运行Spring应用。</p>
</blockquote>
<p>来初始化构建你的工程，引入多数据源将可能会导致事务无效的问题<code>本文重点</code>。因为传统通过xml手动配置更精准，出错也容易查找原因，然而交给SpringBoot自动帮你完成大部分的配置，绝逼满满的都是坑(我的直觉</p>
<span id="more"></span>

<p>好，以下正题。</p>
<p>(本文持久层框架使用MyBatis)</p>
<ul>
<li>  简单的架构是：单个数据源绑定给sessionFactory，再在Dao层操作</li>
</ul>
<p><img src="/img/sprinboot-datasources/datasource.jpg"></p>
<ul>
<li>  若多个数据源的话</li>
</ul>
<p><img src="/img/sprinboot-datasources/datasources.jpg"></p>
<ul>
<li>  sessionFactory都写死在了Dao层，若我再添加个数据源的话，则又得添加一个sessionFactory，这样并不能扩展嘛，所以</li>
</ul>
<p><img src="/img/sprinboot-datasources/dynamic-datasources.jpg"></p>
<p>这样才是坠吼的！</p>
<h2 id="多数据源实现原理："><a href="#多数据源实现原理：" class="headerlink" title="多数据源实现原理："></a>多数据源实现原理：</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>精简篇幅，省略了无关本内容主题的配置</p>
<p>本工程关于数据源的配置在pom.xml，部署各种环境应用不同的数据源，测试两个数据库test1和test2的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.jdbc.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">master.jdbc.driver</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JDBC URL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.jdbc.url</span>&gt;</span>jdbc:mysql://localhost/test1?useUnicode=true<span class="symbol">&amp;amp;</span>autoReconnect=true<span class="tag">&lt;/<span class="name">master.jdbc.url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库用户名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.jdbc.username</span>&gt;</span>root<span class="tag">&lt;/<span class="name">master.jdbc.username</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库密码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.jdbc.password</span>&gt;</span>root<span class="tag">&lt;/<span class="name">master.jdbc.password</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最小连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.db.pool.min</span>&gt;</span>10<span class="tag">&lt;/<span class="name">master.db.pool.min</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池初始连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.db.pool.init</span>&gt;</span>10<span class="tag">&lt;/<span class="name">master.db.pool.init</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最大连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.db.pool.max</span>&gt;</span>20<span class="tag">&lt;/<span class="name">master.db.pool.max</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.jdbc.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">slave.jdbc.driver</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JDBC URL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.jdbc.url</span>&gt;</span>jdbc:mysql://localhost/test2?useUnicode=true<span class="symbol">&amp;amp;</span>autoReconnect=true<span class="tag">&lt;/<span class="name">slave.jdbc.url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库用户名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.jdbc.username</span>&gt;</span>root<span class="tag">&lt;/<span class="name">slave.jdbc.username</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库密码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.jdbc.password</span>&gt;</span>root<span class="tag">&lt;/<span class="name">slave.jdbc.password</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最小连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.db.pool.min</span>&gt;</span>10<span class="tag">&lt;/<span class="name">slave.db.pool.min</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池初始连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.db.pool.init</span>&gt;</span>10<span class="tag">&lt;/<span class="name">slave.db.pool.init</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最大连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.db.pool.max</span>&gt;</span>20<span class="tag">&lt;/<span class="name">slave.db.pool.max</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>application.properties，由SpringBoot自动加载相关属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">master.datasource.name&#x3D;masterDataSource</span><br><span class="line">master.datasource.url&#x3D;@master.jdbc.url@</span><br><span class="line">master.datasource.username&#x3D;@master.jdbc.username@</span><br><span class="line">master.datasource.password&#x3D;@master.jdbc.password@</span><br><span class="line">master.datasource.driver-class-name&#x3D;@master.jdbc.driver@</span><br><span class="line">master.datasource.max-idle&#x3D;@master.db.pool.max@</span><br><span class="line">master.datasource.min-idle&#x3D;@master.db.pool.min@</span><br><span class="line">master.datasource.initial-size&#x3D;@master.db.pool.init@</span><br><span class="line">master.datasource.validation-query&#x3D;select 1</span><br><span class="line">master.datasource.test-on-borrow&#x3D;true</span><br><span class="line">master.datasource.test-while-idle&#x3D;true</span><br><span class="line">slave.datasource.name&#x3D;slaveDataSource</span><br><span class="line">slave.datasource.url&#x3D;@slave.jdbc.url@</span><br><span class="line">slave.datasource.username&#x3D;@slave.jdbc.username@</span><br><span class="line">slave.datasource.password&#x3D;@slave.jdbc.password@</span><br><span class="line">slave.datasource.driver-class-name&#x3D;@slave.jdbc.driver@</span><br><span class="line">slave.datasource.max-idle&#x3D;@slave.db.pool.max@</span><br><span class="line">slave.datasource.min-idle&#x3D;@slave.db.pool.min@</span><br><span class="line">slave.datasource.initial-size&#x3D;@slave.db.pool.init@</span><br><span class="line">slave.datasource.validation-query&#x3D;select 1</span><br><span class="line">slave.datasource.test-on-borrow&#x3D;true</span><br><span class="line">slave.datasource.test-while-idle&#x3D;true</span><br></pre></td></tr></table></figure>

<p>transaction.xml配置需要事务控制的service</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AOP配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--pointcut元素定义一个切入点，execution中的第一个星号 用以匹配方法的返回类型，这里星号表明匹配所有返回类型。</span></span><br><span class="line"><span class="comment">    com.abc.dao.*.*(..)表明匹配com.abc.dao包下的所有类的所有方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;transactionPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.abc.lele.*.service.impl..*.*(..))&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将定义好的事务处理策略应用到上述的切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;transactionPointCut&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--所有以find开头的方法都是只读的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;query*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;is*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;fill*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;count*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;change*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;remove*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;clean*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;active*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;deactive*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;enable*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;disable*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;accept*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--其他方法使用默认事务策略 propagation=&quot;NEVER&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>  <span class="attr">propagation</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扩展Spring的AbstractRoutingDataSource抽象类（该类充当了DataSource的路由中介-能有在运行时-根据某种key值来动态切换到真正的DataSource上。）"><a href="#扩展Spring的AbstractRoutingDataSource抽象类（该类充当了DataSource的路由中介-能有在运行时-根据某种key值来动态切换到真正的DataSource上。）" class="headerlink" title="扩展Spring的AbstractRoutingDataSource抽象类（该类充当了DataSource的路由中介, 能有在运行时, 根据某种key值来动态切换到真正的DataSource上。）"></a>扩展Spring的AbstractRoutingDataSource抽象类（该类充当了DataSource的路由中介, 能有在运行时, 根据某种key值来动态切换到真正的DataSource上。）</h3><p>查看源码，AbstractRoutingDataSource的声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span></span><br></pre></td></tr></table></figure>

<p>它继承了AbstractDataSource，而AbstractDataSource是javax.sql.DataSource的子类，分析它的getConnection方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> determineTargetDataSource().getConnection();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> determineTargetDataSource().getConnection(username, password);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再查看determineTargetDataSource()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">&quot;DataSource router not initialized&quot;</span>);  </span><br><span class="line">    Object lookupKey = determineCurrentLookupKey();</span><br><span class="line">    DataSource dataSource = <span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的重点是determineCurrentLookupKey()方法，这是AbstractRoutingDataSource类中的一个抽象方法，而它的返回值是你所要用的数据源dataSource的key值，有了这个key值，resolvedDataSource（这是个map,由配置文件中设置好后存入的）就从中取出对应的DataSource，如果找不到，就用配置默认的数据源</p>
<p>没错，要扩展AbstractRoutingDataSource类，并重写其中的determineCurrentLookupKey()方法，来实现数据源的切换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteSplitRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DbContextHolder.getDbType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DbContextHolder是我们封装的对数据源进行操作的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbContextHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DbType</span> </span>&#123;</span><br><span class="line">        MASTER,</span><br><span class="line">        SLAVE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DbType&gt; contextHolder = <span class="keyword">new</span> ThreadLocal&lt;DbType&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDbType</span><span class="params">(DbType dbType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dbType == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        contextHolder.set(dbType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DbType <span class="title">getDbType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contextHolder.get() == <span class="keyword">null</span> ? DbType.MASTER : contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDbType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的setDbType()什么时候执行呢？当然是在需要切换数据源的时候执行，应用面向切面，增加一个注解标签，在service层中需要切换数据源的方法上，写上注解标签，调用相应方法切换数据源，这里的@ReadOnlyConnection将在service层中切换到读库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ReadOnlyConnection &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加@Aspect的一个切面拦截类，切换数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadOnlyConnectionInterceptor</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReadOnlyConnectionInterceptor.class);</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(readOnlyConnection)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint, ReadOnlyConnection readOnlyConnection)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;set database connection to read only&quot;</span>);</span><br><span class="line">            DbContextHolder.setDbType(DbContextHolder.DbType.SLAVE);</span><br><span class="line">            Object result = proceedingJoinPoint.proceed();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DbContextHolder.clearDbType();</span><br><span class="line">            logger.info(<span class="string">&quot;restore database connection&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据源加载与事务控制"><a href="#数据源加载与事务控制" class="headerlink" title="数据源加载与事务控制"></a>数据源加载与事务控制</h3><p>还记得上面那个由SpringBoot自动加载相关属性的application.properties么</p>
<p><strong>SpringBoot会自动根据application.properties将数据源属性前缀是spring.datasource配置<code>单数据源</code>，并且初始化相应的SqlSessionFactory(数据库session的连接工厂)与TransactionManager(事务管理器)</strong></p>
<p>这句话是重点，念三遍</p>
<p>所以，在多数据源的需求下，必须要我们手动初始化相应的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;cn.abc.lele.*.mapper&quot;, sqlSessionFactoryRef = &quot;sqlSessionFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext appContext;</span><br><span class="line">    <span class="comment">//初始化主库</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;masterDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;master.datasource&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">masterDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化从库</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;slaveDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;slave.datasource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">slaveDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化数据源bean，这个bean很重要，后面事务控制也会用到</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractRoutingDataSource <span class="title">roundRobinDataSouceProxy</span><span class="params">(<span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span>DataSource master,  <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slave)</span> </span>&#123;</span><br><span class="line">        ReadWriteSplitRoutingDataSource proxy = <span class="keyword">new</span> ReadWriteSplitRoutingDataSource();</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line">        targetDataSources.put(DbContextHolder.DbType.MASTER, master);</span><br><span class="line">        targetDataSources.put(DbContextHolder.DbType.SLAVE,  slave);</span><br><span class="line">        proxy.setDefaultTargetDataSource(master);</span><br><span class="line">        proxy.setTargetDataSources(targetDataSources);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化SqlSessionFactory，将自定义的多数据源ReadWriteSplitRoutingDataSource类实例注入到工厂中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(<span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span>DataSource master, <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slave)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SqlSessionFactoryBean sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBean();       </span><br><span class="line">        sessionFactory.setDataSource((DataSource)appContext.getBean(<span class="string">&quot;roundRobinDataSouceProxy&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，启动工程，多数据源切换能正常执行，但是你会发现事务失效，这是为什么呢？</p>
<p>我们初始化了两个数据源，并且注入给SqlSessionFactory，所以对两个数据源切换并各自访问完全没有问题，让我们回顾一下上面的说过SpringBoot的一个作用：</p>
<p><strong>SpringBoot会自动根据application.properties将数据源属性前缀是spring.datasource配置<code>单数据源</code>，并且初始化相应的SqlSessionFactory(数据库session的连接工厂)与TransactionManager(事务管理器)</strong></p>
<p>所以，这里SpringBoot即使找到数据源属性前缀spring.datasource的数据源配置，也只是单数据源，这就是为什么多数据源切换正常执行，而事务失效的原因！</p>
<p>因为TransactionManager事务管理器里的dataSource根本不是我们的masterDataSource和slaveDataSource(我觉得应该是null，待验证</p>
<p>所以，必须手动初始化一个多数据源的TransactionManager，并且指定bean的名称与上面的transaction.xml中的<code>transaction-manager=&quot;transactionManager&quot;</code>一致！这样，Spring将会使用我们初始化之后的TransactionManager。</p>
<p>新增一个MyDataSourceTransactionManagerAutoConfiguration事务管理器，继承SpringBoot的jar包中DataSourceTransactionManagerAutoConfiguration自动配置数据源事务管理器类，并且构造注入我们初始化的数据源ReadWriteSplitRoutingDataSource的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSourceTransactionManagerAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">DataSourceTransactionManagerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext appContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义事务</span></span><br><span class="line"><span class="comment">     * MyBatis自动参与到spring事务管理中，无需额外配置，只要org.mybatis.spring.SqlSessionFactoryBean引用的数据源与DataSourceTransactionManager引用的数据源一致即可，否则事务管理会不起作用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;transactionManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">transactionManagers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager((DataSource)appContext.getBean(<span class="string">&quot;roundRobinDataSouceProxy&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新启动工程，事务测试通过。</p>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbox快速指南</title>
    <url>/2017/03/07/dubbox%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>该demo的github地址：<a href="https://github.com/zylele/dubbox-demo">dubbox-demo</a></p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>建议在maven安装目录下的<code>conf\settings.xml</code>的<code>&lt;mirrors&gt;</code>标签中添加如下镜像，以提高maven打包速度</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下载dubbox源码并且编译：<span id="more"></span></p>
<blockquote>
<p>git clone <a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;</a>:dangdangdotcom/dubbox.git<br>执行maven命令<code>mvn clean install -Dmaven.test.skip</code></p>
</blockquote>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>推荐使用Zookeeper注册中心</p>
<p><a href="http://dubbo.io/Administrator+Guide.htm#AdministratorGuide-ZookeeperRegistryInstallation">zookeeper安装</a></p>
<p>Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用，参见：<a href="http://zookeeper.apache.org/">Apache ZooKeeper</a></p>
<h2 id="接口定义与通用实体"><a href="#接口定义与通用实体" class="headerlink" title="接口定义与通用实体"></a>接口定义与通用实体</h2><p>common工程只定义了服务提供者与消费者所依赖的接口与实体类</p>
<p>该工程下的接口与实体在服务提供方和消费方共享</p>
<h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>config工程只负责管理dubbo通用配置，在服务提供方和消费方共享，除此之外也可配置如数据库、缓存、队列等等</p>
<h1 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h1><h2 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h2><p>执行初始化init.sql</p>
<p>该demo基于springboot，以properties方式配置公共部分，xml配置各个服务不同之处</p>
<p>config工程引入依赖所需的jar</p>
<p>application.properties中加入注册中心配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo.registry.address&#x3D;@dubbo.registry.address@</span><br></pre></td></tr></table></figure>

<p>具体值请修改pom不同环境打包的profile标签指定</p>
<p>config工程另外配置数据库，缓存等等，这里不再赘述</p>
<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p>引入common与config</p>
<p>新建dubbo-config.xml,更多配置详情请参考<a href="http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C">dubbo配置参考手册</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;base-user-service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;$&#123;dubbo.registry.address&#125;&quot;</span> <span class="attr">file</span>=<span class="string">&quot;c:/dubbo/base-user-service.cache&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 通过注册中心发现监控中心服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;cn.zylele.base&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 服务提供者缺省值配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">&quot;60000&quot;</span> <span class="attr">delay</span>=<span class="string">&quot;-1&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务提供者实现服务接口，这里的@Service的注解是dubbo的服务提供方注解，声明需要暴露的服务接口，并指定实现</p>
<p>注：服务既可以是提供者也可以是消费者，下面的DynamicQueryService为另一个服务。</p>
<p><code>@Reference</code>是dubbo的服务消费方注解，生成远程服务代理，来引用别的服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserQueryServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserQueryService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference(check = false)</span></span><br><span class="line">    DynamicQueryService dynamicQueryService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String userid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUser(userid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动入口，发布服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(value = &quot;classpath:*.xml&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProvider</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication app = <span class="keyword">new</span> SpringApplication(UserServiceProvider.class);</span><br><span class="line">        app.setWebEnvironment(<span class="keyword">false</span>);</span><br><span class="line">        app.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p>引入common</p>
<p>application.properties中加入注册中心配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo.registry.address&#x3D;@dubbo.registry.address@</span><br></pre></td></tr></table></figure>

<p>具体值请修改pom不同环境打包的profile标签指定</p>
<p>新建dubbo-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;base-consumer&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用zookeeper注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;$&#123;dubbo.registry.address&#125;&quot;</span> <span class="attr">file</span>=<span class="string">&quot;c:/dubbo/base-consumer.cache&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过注册中心发现监控中心服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;cn.zylele.base&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 关闭所有服务的启动时检查 check=false，总是会返回引用，当服务恢复时，能自动连上--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发现并调用远程服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    UserQueryService userQueryService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/user/get/&#123;userid&#125;&quot;,method=RequestMethod.GET, </span></span><br><span class="line"><span class="meta">        produces = MediaType.APPLICATION_JSON_VALUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">readUserInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;userid&quot;)</span> String userid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userQueryService.getUser(userid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动工程，调试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(value = &quot;classpath:dubbo-config.xml&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseConsumer</span> <span class="keyword">implements</span> <span class="title">EmbeddedServletContainerCustomizer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(BaseConsumer.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">        container.setPort(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>dubbox还具有相当多的配置功能，如负载均衡、集群容错，多协议、多注册中心等</p>
<p>更多示例与参考手册，可查看<a href="http://dubbo.io/User+Guide-zh.htm">dubbo用户指南</a></p>
]]></content>
      <tags>
        <tag>Dubbox</tag>
      </tags>
  </entry>
  <entry>
    <title>开源dubbokeeper MySQL快速启动版</title>
    <url>/2017/04/01/%E4%BA%8C%E6%AC%A1%E5%BC%80%E6%BA%90dubbokeeper%20MySQL%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%89%88/</url>
    <content><![CDATA[<p>github地址：<a href="https://github.com/zylele/dubbokeeper-mqs">dubbokeeper-mqs</a></p>
<h2 id="dubbokeeper-mqs是什么"><a href="#dubbokeeper-mqs是什么" class="headerlink" title="dubbokeeper-mqs是什么"></a>dubbokeeper-mqs是什么</h2><p>dubbokeeper-mqs是基于Spring mvc开发的社区版dubboadmin集成服务管理以及服务监控一体的DUBBO服务管理系统，自<a href="https://github.com/dubboclub/dubbokeeper">dubbokeeper</a>基础上整合而成的<strong>MySQL快速启动版</strong>，并新增服务预警接口、权限登录功能</p>
<p>dubbokeeper-mqs集成监控与展示，节省服务器资源，提供一键编译部署</p>
<span id="more"></span>

<h2 id="dubbokeeper-mqs包含哪些功能"><a href="#dubbokeeper-mqs包含哪些功能" class="headerlink" title="dubbokeeper-mqs包含哪些功能"></a>dubbokeeper-mqs包含哪些功能</h2><ul>
<li>应用管理</li>
<li>动态配置</li>
<li>统计信息</li>
<li>Dubbo服务监控</li>
<li>zookeeper信息查看</li>
<li>服务预警</li>
</ul>
<hr>
<p>执行数据库初始化脚本<code>application.sql</code>，数据库名可以自定义一个，编码采用utf-8</p>
<h2 id="服务预警"><a href="#服务预警" class="headerlink" title="服务预警"></a>服务预警</h2><p>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</p>
<p>修改<code>com.dubboclub.dk.alarm.impl.AlarmServiceImpl</code>的<code>void alarmHandle(URL url)</code>的实现即可(服务提供者全部宕掉后，将会触发该方法)，通过<code>url.getServiceInterface()</code>获取服务名，发送邮件、发送短信等</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>只需配置<code>src/main/resources/dubbo.properties</code>与<code>pom.xml</code>的各属性值</p>
<p>打包部署到Tomcat启动</p>
<hr>
<p><img src="/img/dubbokeeper-mqs/dubbokeeper-service.png"></p>
<p>动态配置</p>
<p><img src="/img/dubbokeeper-mqs/dubbokeeper-dpc.png"></p>
<p>依赖关系</p>
<p><img src="/img/dubbokeeper-mqs/dubbokeeper-monitor.png"></p>
<p>统计信息</p>
]]></content>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Spring Boot与Dubbo REST</title>
    <url>/2017/07/08/%E5%85%B3%E4%BA%8ESpring%20Boot%E4%B8%8EDubbo%20REST/</url>
    <content><![CDATA[<h2 id="关于Spring-Boot"><a href="#关于Spring-Boot" class="headerlink" title="关于Spring Boot"></a>关于Spring Boot</h2><p>Spring Boot的设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域成为领导者。</p>
<span id="more"></span>

<p>Spring Boot(英文中是“引导”的意思)，是用来简化Spring应用的搭建到开发的过程。应用开箱即用，只要通过 “just run”（可能是 java -jar 或 tomcat 或 maven插件run 或 shell脚本），就可以启动项目。二者，Spring Boot 只要很少的Spring配置文件（例如那些xml，property）。</p>
<p>因为“习惯优先于配置”的原则，使得Spring Boot在快速开发应用和微服务架构实践中得到广泛应用。</p>
<h2 id="Spring-Boot整合Dubbo实现SOA"><a href="#Spring-Boot整合Dubbo实现SOA" class="headerlink" title="Spring Boot整合Dubbo实现SOA"></a>Spring Boot整合Dubbo实现SOA</h2><p>Spring Boot对于作为微服务的框架来说</p>
<p>优点：</p>
<ul>
<li>嵌入式Tomcat、Jetty容器，无需部署war包</li>
<li>遵循”习惯优于配置”原则，只需很少的配置，大部分时候可以使用默认配置</li>
<li>项目快速搭建</li>
<li>丰富的和第三方框架无配置整合的jar包</li>
</ul>
<p>缺点：</p>
<ul>
<li>坑有些多, 文档略少</li>
<li>简单的背后蕴藏了较大的学习曲线</li>
</ul>
<p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，有以下几个特性</p>
<ul>
<li>远程通信，向本地调用一样调用远程方法。</li>
<li>集群容错</li>
<li>服务自动发现和注册，可平滑添加或者删除服务提供者。</li>
</ul>
<p>一般而言，我们常常暴露HTTP服务，并走JSON模式。但慢慢量大了，缺少一种SOA的治理方案。之后整合Dubbo服务治理方案实现SOA，这样可以暴露出Dubbo服务接口，提供给Dubbo消费者进行RPC调用。</p>
<p>可以看出，Dubbo才是应用服务化绝对的核心，在这过程中，Spring Boot扮演为Dubbo提供服务启动初始化入口，整合各种第三方框架，为Dubbo服务提供各组件支持的角色</p>
<p>所以，Spring Boot在已经部署Dubbo服务的情况下，只作为容器来说没有必要使用</p>
<hr>
<h2 id="Dubbo服务的开放"><a href="#Dubbo服务的开放" class="headerlink" title="Dubbo服务的开放"></a>Dubbo服务的开放</h2><h3 id="概述与应用场景"><a href="#概述与应用场景" class="headerlink" title="概述与应用场景"></a>概述与应用场景</h3><p>以REST为例</p>
<p>Dubbo支持多种远程调用方式，基于简单的文本格式消息和通用的HTTP协议，使它具备极广的适用性，几乎所有语言和平台都对它提供支持，同时其学习和使用的门槛也较低。</p>
<p>在dubbo中支持REST，可以为当今多数主流的远程调用场景都带来（显著）好处：</p>
<blockquote>
<p>显著简化企业内部的异构系统之间的（跨语言）调用。此处主要针对这种场景：dubbo的系统做服务提供端，其他语言的系统（也包括某些不基于dubbo的java系统）做服务消费端，两者通过HTTP和文本消息进行通信。即使相比Thrift、ProtoBuf等二进制跨语言调用方案，REST也有自己独特的优势（详见后面讨论）</p>
</blockquote>
<blockquote>
<p>显著简化对外Open API（开放平台）的开发。既可以用dubbo来开发专门的Open API应用，也可以将原内部使用的dubbo service直接“透明”发布为对外的Open REST API（当然dubbo本身未来最好可以较透明的提供诸如权限控制、频次控制、计费等诸多功能）</p>
</blockquote>
<blockquote>
<p>显著简化手机（平板）APP或者PC桌面客户端开发。类似于2，既可以用dubbo来开发专门针对无线或者桌面的服务器端，也可以将原内部使用的dubbo service直接”透明“的暴露给手机APP或桌面程序。当然在有些项目中，手机或桌面程序也可以直接访问以上场景2中所述的Open API。</p>
</blockquote>
<blockquote>
<p>显著简化浏览器AJAX应用的开发。类似于2，既可以用dubbo来开发专门的AJAX服务器端，也可以将原内部使用的dubbo service直接”透明“的暴露给浏览器中JavaScript。当然，很多AJAX应用更适合与web框架协同工作，所以直接访问dubbo service在很多web项目中未必是一种非常优雅的架构。</p>
</blockquote>
<blockquote>
<p>为企业内部的dubbo系统之间（即服务提供端和消费端都是基于dubbo的系统）提供一种基于文本的、易读的远程调用方式。</p>
</blockquote>
<blockquote>
<p>一定程度简化dubbo系统对其它异构系统的调用。可以用类似dubbo的简便方式“透明”的调用非dubbo系统提供的REST服务（不管服务提供端是在企业内部还是外部）</p>
</blockquote>
<blockquote>
<p><strong>需要指出的是，我认为1～3是dubbo的REST调用最有价值的三种应用场景，并且我们为dubbo添加REST调用，其最主要到目的也是面向服务的提供端，即开发REST服务来提供给非dubbo的（异构）消费端。</strong></p>
</blockquote>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><p>Dubbo REST的服务能和Dubbo注册中心、监控中心集成吗？</p>
<blockquote>
<p>可以的，而且是自动集成的，也就是你在dubbo中开发的所有REST服务都会自动注册到服务册中心和监控中心，可以通过它们做管理。</p>
</blockquote>
<blockquote>
<p>但是，只有当REST的消费端也是基于dubbo的时候，注册中心中的许多服务治理操作才能完全起作用。而如果消费端是非dubbo的，自然不受注册中心管理，所以其中很多操作是不会对消费端起作用的。</p>
</blockquote>
<p>Dubbo REST中如何实现负载均衡和容错（failover）？</p>
<blockquote>
<p>如果dubbo REST的消费端也是dubbo的，则Dubbo REST和其他dubbo远程调用协议基本完全一样，由dubbo框架透明的在消费端做load balance、failover等等。</p>
</blockquote>
<blockquote>
<p>如果dubbo REST的消费端是非dubbo的，甚至是非java的，则最好配置服务提供端的软负载均衡机制，目前可考虑用LVS、HAProxy、 Nginx等等对HTTP请求做负载均衡。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于这个博客</title>
    <url>/2015/01/12/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>好多事情都要自己去做的时候才知道会碰到很多问题。</p>
<blockquote class="blockquote-center">纸上得来终觉浅，
绝知此事要躬行。</blockquote>

<p>以下都是免费开源的，任何人都可以使用和修改。</p>
<p>不同于wordpress，hexo由于需要使用Github，Git，Markdown，Node，js这样的工具，好多插件、widget都需要自己安装、设置。点击这个<a href="http://www.jianshu.com/p/465830080ea9">HEXO+Github,搭建属于自己的博客</a>或许会帮助到你。感谢issnan的<a href="https://github.com/iissnan/hexo-theme-next">NexT主题</a>。</p>
<span id="more"></span>

<p>GitHub是全球最大的开源代码托管网站，Github很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如jQuery、Twitter等。</p>
<p>Github提供了Github Pages的服务，不仅可以方便的为项目建立介绍站点，允许用户自定义项目首页，用来替代默认的源码列表。也可以用来建立个人博客。</p>
<p>所以，GitHub Pages可以被认为是用户编写的、托管在GitHub上的静态网页。</p>
<p>hexo是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在GitHub和Heroku上。配合git版本控制系统，能方便提交内容更新到本地仓库，并远程部署到GitHub Pages上。</p>
<p>以上</p>
]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈依赖注入--Dependency Injection</title>
    <url>/2015/05/16/%E6%B5%85%E8%B0%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5--Dependency%20Injection/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Spring</strong>能有效地组织J2EE应用各层的对象。不管是控制层的Action对象，还是业务层的Service对象，还是持久层的DAO对象，都可在Spring的 管理下有机地协调、运行。Spring将各层的对象以<code>松耦合</code>的方式组织在一起，Action对象无须关心Service对象的具体实现，Service对 象无须关心持久层对象的具体实现，各层对象的调用<code>完全面向接口</code>。当系统需要重构时，代码的改写量将大大减少。</p>
<span id="more"></span>

<p>上面所说的一切都得宜于Spring的核心机制，<code>依赖注入</code>。</p>
<blockquote>
<p>依赖注入让bean与bean之间以配置文件组织在一起，而不是以硬编码的方式耦合在一起。</p>
</blockquote>
<p>依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。具体含义是:</p>
<blockquote>
<p>当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。</p>
</blockquote>
<p>不管是依赖注入，还是控制反转，都说明Spring采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现互相透明。在理解依赖注入之前，看如下这个问题在各种社会形态里如何解决:</p>
<p><strong><code>一个人</code>(Java实例，调用者)需要一把<code>斧子</code>(Java实例，被调用者)</strong></p>
<ul>
<li><p>  原始社会里，几乎没有社会分工。需要斧子的人(调用者)只能自己去磨一把斧子(被调用者)。对应的情形为:Java程序里的调用者自己创建被调用者。</p>
</li>
<li><p>  进入工业社会，工厂出现。斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人(调用者)找到工厂，购买斧子，无须关心斧子的制造过程。对应Java程序的简单工厂的设计模式。</p>
</li>
<li><p>  进入“按需分配”社会，需要斧子的人不需要找到工厂，坐在家里发出一个简单指令:需要斧子。斧子就自然出现在他面前。对应Spring的依赖注入。</p>
</li>
</ul>
<p><em>第一种情况下，Java实例的调用者创建被调用的Java实例，必然要求被调用的Java类出现在调用者的代码里。无法实现二者之间的松耦合。</em></p>
<p><em>第二种情况下，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准(接口)的实例，即可使用。此时调用的代码面向接口编程，可以让调用者和被调用者解耦，这也是工厂模式大量使用的原因。但调用者需要自己定位工厂，调用者与特定工厂耦合在一起。</em></p>
<p><em>第三种情况下，调用者无须自己定位工厂，程序运行到需要被调用者时，系统自动提供被调用者实例。事实上，调用者和被调用者都处于Spring的管理下，二者之间的依赖关系由Spring提供。</em></p>
<hr>
<h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><p>所谓依赖注入，是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对POJO之间依赖关系的管理。依赖注入通常有两种:</p>
<ul>
<li><p>  设值注入。</p>
</li>
<li><p>  构造注入。</p>
</li>
</ul>
<h3 id="设值注入"><a href="#设值注入" class="headerlink" title="设值注入"></a>设值注入</h3><p>设值注入是指通过setter方法传入被调用者的实例。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。看下面代码，是Person的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//Person接口里定义一个使用斧子的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后是Axe的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义Axe接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Axe</span></span>&#123;</span><br><span class="line">    <span class="comment">//Axe接口里有个砍的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Person的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Chinese实现Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//面向Axe接口编程，而不是具体的实现类</span></span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="comment">//默认的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//设值注入所需的setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现Person接口的useAxe方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Axe的第一个实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Axe的第一个实现类 StoneAxe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoneAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span></span>&#123;</span><br><span class="line">    <span class="comment">//默认构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StoneAxe</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//实现Axe接口的chop方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;石斧砍柴好慢&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面采用Spring的配置文件将Person实例和Axe实例组织在一起。配置文件如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring配置文件的根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BEANS</span>&gt;</span></span><br><span class="line">&lt;!—定义第一bean，该bean的id是chinese, class指定该bean实例的实现类 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">BEAN</span> <span class="attr">class</span>=<span class="string">lee.Chinese</span> <span class="attr">id</span>=<span class="string">chinese</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- property元素用来指定需要容器注入的属性，axe属性需要容器注入此处是设值注入，因此Chinese类必须拥有setAxe方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;axe&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处将另一个bean的引用注入给chinese bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">REF</span> <span class="attr">local</span>=<span class="string">&quot;”stoneAxe”/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BEAN</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义stoneAxe bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BEAN</span> <span class="attr">class</span>=<span class="string">lee.StoneAxe</span> <span class="attr">id</span>=<span class="string">stoneAxe</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BEANS</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从配置文件中，可以看到Spring管理bean的灵巧性。bean与bean之间的依赖关系放在配置文件里组织，而不是写在代码里。通过配置文件的 指定，Spring能精确地为每个bean注入属性。因此，配置文件里的bean的class元素，不能仅仅是接口，而必须是真正的实现类。</p>
<p>Spring会自动接管每个bean定义里的property元素定义。Spring会在执行无参数的构造器后、创建默认的bean实例后，调用对应 的setter方法为程序注入属性值。property定义的属性值将不再由该bean来主动创建、管理，而改为被动接收Spring的注入。</p>
<p>每个bean的id属性是该bean的惟一标识，程序通过id属性访问bean，bean与bean的依赖关系也通过id属性完成。</p>
<p>下面看主程序部分:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//因为是独立的应用程序，显式地实例化Spring的上下文。</span></span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//通过Person bean的id来获取bean实例，面向接口编程，因此此处强制类型转换为接口类型</span></span><br><span class="line">        Person p = (Person)ctx.getBean(<span class="string">&quot;chinese&quot;</span>);</span><br><span class="line">        <span class="comment">//直接执行Person的userAxe()方法。</span></span><br><span class="line">        p.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序的执行结果如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">石斧砍柴好慢</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主程序调用Person的useAxe()方法时，该方法的方法体内需要使用Axe的实例，但程序里<code>没有任何地方</code>将特定的Person实例和Axe实例<code>耦合</code>在一起。或者说，程序里没有为Person实例传入Axe的实例，Axe实例由Spring在运行期间动态注入。</p>
<p>Person实例不仅不需要了解Axe实例的具体实现，甚至无须了解Axe的创建过程。程序在运行到需要Axe实例的时候，Spring创建了Axe 实例，然后注入给需要Axe实例的调用者。Person实例运行到需要Axe实例的地方，自然就产生了Axe实例，用来供Person实例使用。</p>
<p>调用者不仅<code>无须关心被调用者的实现过程</code>，连工厂定位都可以省略(<del>真的是按需分配啊!</del>)。</p>
<p>如果需要改写Axe的实现类。或者说，提供另一个实现类给Person实例使用。Person接口、Chinese类都无须改变。只需提供另一个Axe的实现，然后对配置文件进行简单的修改即可。</p>
<p>Axe的另一个实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Axe的另一个实现类 SteelAxe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span></span>&#123;</span><br><span class="line">    <span class="comment">//默认构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//实现Axe接口的chop方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;钢斧砍柴真快&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，修改原来的Spring配置文件，在其中增加如下一行:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义一个steelAxe bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BEAN</span> <span class="attr">class</span>=<span class="string">lee.SteelAxe</span> <span class="attr">id</span>=<span class="string">steelAxe</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该行重新定义了一个Axe的实现:SteelAxe。然后修改chinese bean的配置，将原来传入stoneAxe的地方改为传入steelAxe。也就是将</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">REF</span> <span class="attr">local</span>=<span class="string">&quot;”stoneAxe”/&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改成</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">REF</span> <span class="attr">local</span>=<span class="string">&quot;”steelAxe”/&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时再次执行程序，将得到如下结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">钢斧砍柴真快</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Person与Axe之间没有任何代码耦合关系，bean与bean之间的依赖关系由Spring管理。采用setter方法为目标bean注入属性的方式，称为设值注入。</p>
<p>业务对象的更换变得相当简单，对象与对象之间的依赖关系从代码里分离出来，通过配置文件动态管理。</p>
<h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><p>所谓构造注入，指通过构造函数来完成依赖关系的设定，而不是通过setter方法。对前面代码Chinese类做简单的修改，修改后的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Chinese实现Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//面向Axe接口编程，而不是具体的实现类</span></span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="comment">//默认的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//构造注入所需的带参数的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinse</span><span class="params">(Axe axe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现Person接口的useAxe方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时无须Chinese类里的setAxe方法，构造Person实例时，Spring为Person实例注入所依赖的Axe实例。构造注入的配置文件也需做简单的修改，修改后的配置文件如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring配置文件的根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BEANS</span>&gt;</span></span><br><span class="line">&lt;!—定义第一个bean，该bean的id是chinese, class指定该bean实例的实现类 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">BEAN</span> <span class="attr">class</span>=<span class="string">lee.Chinese</span> <span class="attr">id</span>=<span class="string">chinese</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BEAN</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义stoneAxe bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BEAN</span> <span class="attr">class</span>=<span class="string">lee.SteelAxe</span> <span class="attr">id</span>=<span class="string">steelAxe</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BEANS</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行效果与使用steelAxe设值注入时的执行效果<code>完全一样</code>。区别在于:创建Person实例中Axe属性的<code>时机</code>不同——设值注入是现创建一个默认的bean实例，然后调用对应的构造方法注入依赖关系。而构造注入则在创建bean实例时，已经完成了依赖关系的。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title>用Travis CI自动部署GitHub项目</title>
    <url>/2017/09/10/%E7%94%A8Travis%20CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2GitHub%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>介绍一套免费持续集成构建部署解决方案。</p>
<p><img src="/img/travis-ci/day-day-poor.jpg" alt="Poor Guy"></p>
<p>本文以部署基于Node.js的静态博客框架hexo为例</p>
<p>源码地址：<a href="https://github.com/zylele/blog">zylele/blog</a></p>
<span id="more"></span>

<h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p>顾名思义，Travis CI是一个持续集成(Continuous integration，简称CI)的工具。它可以在公共的Github仓库上免费使用。</p>
<blockquote>
<p>Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。</p>
</blockquote>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h3 id="在Github建立代码库"><a href="#在Github建立代码库" class="headerlink" title="在Github建立代码库"></a>在Github建立代码库</h3><p>首先，要在Github上建立一个代码仓库，要将自己hexo博客push到上面。hexo项目作为运行部署的项目，然后Github Page的项目作为部署的目标项目。</p>
<h3 id="开启Travis-CI"><a href="#开启Travis-CI" class="headerlink" title="开启Travis CI"></a>开启Travis CI</h3><p>第二步，我们需要有一个Travis CI的账号，直接进入<a href="https://travis-ci.org/">Travis CI</a>官网，用自己的Github账号授权登录即可。</p>
<p>然后可以看到当前账号的所有代码仓库，接下来将博客项目的状态设置为启用。</p>
<p><img src="/img/travis-ci/account.png" alt="turn on travis"></p>
<h3 id="创建SSH-key"><a href="#创建SSH-key" class="headerlink" title="创建SSH key"></a>创建SSH key</h3><p><strong>如果你的github已经配置过SSH了，可以省略这一步，或者你想缩小权限控制粒度，可继续执行这一步骤。</strong></p>
<p>第三步，创建一个部署在Travis CI上面的SSH key利用这个SSH key可以让Travis CI向我们自己的项目提交代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>得到<code>id_rsa.pub</code>和<code>id_rsa</code>，然后将有<code>pub</code>后缀的配置到Deploy key。</p>
<p><img src="/img/travis-ci/deploy-key.png" alt="set deploy key"></p>
<p>记得要将<code>Allow write access</code>的选项选上，这样Travis CI才能获得push代码的权限。</p>
<h3 id="加密私钥"><a href="#加密私钥" class="headerlink" title="加密私钥"></a>加密私钥</h3><p>刚才讲公钥文件配置好了，然后就要配置私钥文件，在hexo项目下面建立一个<code>.travis</code>的文件夹来放置需要配置的文件。</p>
<p>首先要安装travis命令行工具(如果在国内的网络环境下建议安装之前先<a href="https://ruby.taobao.org/">换源</a>)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem install travis</span><br></pre></td></tr></table></figure>

<p>用命令行工具登录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ travis login --auto</span><br></pre></td></tr></table></figure>

<p>然后将刚刚生成的<code>id_rsa</code>复制到<code>.travis</code>文件夹，用命令行工具进行加密：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ travis encrypt-file id_rsa --add</span><br></pre></td></tr></table></figure>

<p>这个时候会生成加密之后的秘钥文件<code>id_rsa.enc</code>，原来的文件<code>id_rsa</code>就可以删掉了。</p>
<p>这时可以看到终端输出了一段</p>
<p><code>openssl aes-256-cbc -K $encrypted_xxxxxxxxxxx_key -iv $encrypted_xxxxxxxxxxx_iv</code></p>
<p>这样格式的信息，这是travis用来解密<code>id_rsa.enc</code>的key，先保存起来，后面配置<code>.travis.yml</code>会用到它。</p>
<p>为了让git默认连接SSH还要创建一个<code>ssh_config</code>文件。在<code>.travis</code>文件夹下创建一个<code>ssh_config</code>文件，输入以下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line">    <span class="string">User</span> <span class="string">git</span></span><br><span class="line">    <span class="string">StrictHostKeyChecking</span> <span class="literal">no</span></span><br><span class="line">    <span class="string">IdentityFile</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">    <span class="string">IdentitiesOnly</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<p>现在进入travis CI设置页面</p>
<p><img src="/img/travis-ci/setting.png" alt="travis setting"></p>
<p>可以看到刚刚travis命令行生成的解密key</p>
<p><img src="/img/travis-ci/environment-variables.png" alt="environment variables"></p>
<p>顺便把上面的开关打开</p>
<p><img src="/img/travis-ci/turn-on-build.png" alt="trun on travis setting"></p>
<p>这样，当向项目push代码的时候travis CI就会根据<code>.travis.yml</code>的内容去部署我们的项目了。</p>
<h3 id="travis-yml"><a href="#travis-yml" class="headerlink" title=".travis.yml"></a>.travis.yml</h3><p>最后就要配置<code>.travis.yml</code>。在项目的根目录创建<code>.travis.yml</code>文件。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置语言及相应版本</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"><span class="comment"># 项目所在分支</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="comment"># node_modules 缓存</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"><span class="comment"># 配置环境</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="comment"># 替换为刚才生成的解密信息</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="string">-K</span> <span class="string">$encrypted_xxxxxxxxx_key</span> <span class="string">-iv</span> <span class="string">$encrypted_xxxxxxxxx_iv</span> <span class="string">-in</span> <span class="string">.travis/id_rsa.enc</span> <span class="string">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="string">-d</span></span><br><span class="line"><span class="comment"># 改变文件权限</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="comment"># 配置 ssh</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">eval</span> <span class="string">$(ssh-agent)</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ssh-add</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cp</span> <span class="string">.travis/ssh_config</span> <span class="string">~/.ssh/config</span></span><br><span class="line"><span class="comment"># 配置 git 替换为自己的信息</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&#x27;zylele&#x27;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="number">657345933</span><span class="string">@qq.com</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="comment"># 部署的命令</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure>

<p>好了现在只要向项目push代码就可以触发部署了，进入<a href="https://travis-ci.org/">https://travis-ci.org</a>就可以看到部署的过程了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在部署了一遍之后发现，运行<code>npm install</code>安装node的库时候占据了部署的很大一部分时间，这里有一个技巧，可以将<code>node_modules</code>缓存起来，这样可以节省部署的时间。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># node_modules 缓存</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node_modules</span></span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><code>.travis.yml</code>的完整代码可以看我的<a href="https://github.com/zylele/blog/blob/master/.travis.yml">.travis.yml</a>文件。博客的完整代码可以看<a href="https://github.com/zylele/blog">这里</a>。</p>
]]></content>
      <tags>
        <tag>持续集成</tag>
      </tags>
  </entry>
</search>
